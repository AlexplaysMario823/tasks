<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapters 50-52</title>
</head>
<body>
    <h1>Chapters 50-52</h1>
    <h2>Chapter 50 - <a href="https://dictionary.cambridge.org/dictionary/english/thinking">Thinking</a> logically, thinking concurrently</h2>
    <p>
        This chapter is about planning ahead to make sure your code will be as efficient as posible.
        The structured approach makes your code more clear and easy to modify in the future. Structured programming includes the folowing
    </p>
    <ol>
        <li>Sequence(statements going in order)</li>
        <li>Selection(if/else statements and in some language (like Javascript) switch statements)</li>
        <li>Iteration(while or for loops)</li>
    </ol>
    <p>
        Pseudocode and flow charts/diagrams are the main tools for designing algorithms. 
        Pseudocode is a language that isn't very well defined so there can be multiple ways for writing the same code (e.g. using an arrow sign versus an equals sign).
        Errors can often happen when there is userinterface that the programmer hadn't planned for.
        Trace tables are good for checking mistakes in simple algorithms.
    </p>
    <p>
        Thinking concurrently means you are thinking about multiple things at the same time. The difference between Parrallel computing and concurrent processing is that Parrallel requires multiple procesors but concurrent has one processor and givesa each task a slice so it appears like it it handling everything at the same time.

        Advantages and disadvantages of both of these include:
    </p>
    <h3>For concurrent processing</h3>
    <ol>
        <li>The number of task completed per second increases</li>
        <li>It can do other tasks while waiting</li>
        <li>if there are too many users it becomes slow</li>
    </ol>
    <h3>For Parrallel processing</h3>
    <ol>
        <li>It can speed up proccessing alot when repetitive calcultion need to be done to a large amount of data 

        </li>
        <li>Can quickly render a 3d object</li>
        <li>Some tasks may run faster with one processor</li>
    </ol>
    <h2>Chapter 51 - Problem recognition</h2>
    <p>
        Problem recognition is used to solve a solve a problem. A problem is called computable if an algorithm can solve in every case of it in a finite number of steps. Some problems sre computable but take so long that they might as well be insoluble (e.g. cracking a password).
        Here are four common ways of problem solving:

    </p>
    <ul>
        <li>enumeration(testing all cases)</li>
        <li>simulation</li>
        <li>theoretical approach</li>
        <li>creative solution</li>
    </ul>
    <h3>Enumeration</h3>
    <p>
        Many problems can be solved using this approach (exhaustive search) but the problem is that it might take too long even for a computer to do this and could be improved to be more efficient and quicker
    </p>
    <h3>Simulation</h3>
    <p>
        Simulation can help you create a model of reality using abstraction (removing unnessesary detail). Simulation can be used to model population predictions, queueing problems etc.
    </p>
    <h3>Strategies for problem solving</h3>
    <p>
        Decompostion breaks big tasks into many smaller tasks. You can repeat this several times until the tasks are manageable.
        Divide and conquer is another problem solving technique that reduces the size of the problem every iteration. One example of this is binary search. This halves the list of numbers every time a comparison is made.
        Abstraction is removing unnessesary details to solve a problem more easily. 
    </p>
    <h3>Automation</h3>
    <p>
        Automation puts things into action models to solve problems. These models might allow you to spot details you couldn't before.
    </p>
    <h2>Chapter 52 - Problem solving</h2>
    <img src="./files/Creative-Problem-Solving-Process.jpeg" alt="">
    <h3>Visualisation</h3>
    <p>
        Visualisation can be very helpful when it comes to Problem solving because it makes it easier for certain details to be spotted and it makes it hard for those details to be forgotten.
    </p>
    <h3>Backtracking</h3>
    <p>
        In some problems you will not have the information to know which is the best route to take imediately because there are lots of routes that lead to lots of other routes and sometimes you might need to find all solutions meaning you'll have to search everywhere.
        Backtracking is a methodical way of trying different combination of sequences until you find the one that leads to the solution. An example of this is solving a maze.
    </p>

</body>
</html>